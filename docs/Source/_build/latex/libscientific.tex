%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{libscientific Documentation}
\date{Jun 03, 2022}
\release{1.2.4}
\author{Giuseppe Marco Randazzo}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{What is libscientific?}
\label{\detokenize{Overview:what-is-libscientific}}\label{\detokenize{Overview::doc}}
\sphinxAtStartPar
Libscientific aims to do numerical/multivariate and statistical analysis.
The library is written in C language for almost all the computations except
for a few methods such as the singular value decomposition (SVD) and
the eigenvector/eigenvalue transformation from a third\sphinxhyphen{}party library, the Lapack library.
It requires two dependencies: CMake and a c/fortran compiler
and supports Windows, Linux, macOS, and embedded systems.
Python bindings are available using ctypes to avoid dependencies.
The library is distributed under GPLv3 license allowing it
to be used for public and commercial purposes.

\sphinxAtStartPar
The significant advantage of libscientific is that it does not require dependencies
unless a c/fortran compiler and CMake. Moreover, the size of the library is under 1.5MB.
Libscientific also has been tested with old computers.


\section{What can I do with libscientific?}
\label{\detokenize{Overview:what-can-i-do-with-libscientific}}\begin{itemize}
\item {} \begin{description}
\item[{Multivariate analysis:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Principal Component Analysis using the NIPALS algorithm

\item {} 
\sphinxAtStartPar
Partial Least Squares (PLS) using the NIPALS algorithm (Regression and Classification)

\item {} 
\sphinxAtStartPar
Multiple Linear Regression (MLR) using the Ordinary Least Squares algorithm

\item {} 
\sphinxAtStartPar
Linear Discriminant Analysis (LDA) using the Fisher algorithm

\item {} 
\sphinxAtStartPar
Multi\sphinxhyphen{}waw unfolding PCA (UPCA) using the S. Wold, P. Geladi and K. Esbensen algorithm

\item {} 
\sphinxAtStartPar
Multi\sphinxhyphen{}way unfolding PLS (UPLS) using the S. Wold, P. Geladi and K. Esbensen algorithm

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Matrix/Vector/Tensor computations:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Matrix/Vector and Vector/Matrix dot product

\item {} 
\sphinxAtStartPar
Matrix/Matrix dot product

\item {} 
\sphinxAtStartPar
Vector/Vector dot product

\item {} 
\sphinxAtStartPar
Matrix inversion using the Gauss\sphinxhyphen{}Jordan algorithm or the LU decomposition

\item {} 
\sphinxAtStartPar
Matrix pseudo inversion using the Moore\sphinxhyphen{}Penrose formula

\item {} 
\sphinxAtStartPar
Matrix transpose

\item {} 
\sphinxAtStartPar
Tensor/Tensor dot product

\item {} 
\sphinxAtStartPar
Vector/Matrix Kronecker product

\item {} 
\sphinxAtStartPar
Tensor/Matrix dot product

\item {} 
\sphinxAtStartPar
Tensor transpose

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Statistical analysis:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Descriptive statistics of a matrix

\item {} 
\sphinxAtStartPar
R squared (R\textasciicircum{}2)

\item {} 
\sphinxAtStartPar
Mean absolute error (MAE)

\item {} 
\sphinxAtStartPar
Mean squared error (MSE)

\item {} 
\sphinxAtStartPar
Root mean squared error (RMSE)

\item {} 
\sphinxAtStartPar
Bias estimation (BIAS)

\item {} 
\sphinxAtStartPar
Sensitivity binary classification test

\item {} 
\sphinxAtStartPar
Positive predicted values binary classification test

\item {} 
\sphinxAtStartPar
Receiver operating characteristic curve (ROC)

\item {} 
\sphinxAtStartPar
Precision\sphinxhyphen{}Recal curve (PR)

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Design of experiment:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Bifactorial matrix expansion used in design of experiments (DOE)

\item {} 
\sphinxAtStartPar
Yates analysis to assess the variable effects in a DOE

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Clustering:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
K\sphinxhyphen{}Means with different initialization (Random, ++ and so on) for divisive clustering

\item {} 
\sphinxAtStartPar
Hierarchical clustering for aglomerative clustering

\item {} 
\sphinxAtStartPar
Hyper grid map which create clusters dividing the hyperspace into a hyper grid and abundance score plot

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Instance/Object selection:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Most descriptive compound selection

\item {} 
\sphinxAtStartPar
Maximum dissimilarity selection

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Optimization:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Downhill optimization using the Nelder\textendash{}Mead method aka Simplex method

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Interpolation:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Natural cubic spline interpolation

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Similarity analysis:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Euclidean distance analysis

\item {} 
\sphinxAtStartPar
Manhattan distance analysis

\item {} 
\sphinxAtStartPar
Cosine distance analysis

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Model validation:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Leave\sphinxhyphen{}One\sphinxhyphen{}Out

\item {} 
\sphinxAtStartPar
K\sphinxhyphen{}Fold cross validation

\item {} 
\sphinxAtStartPar
Repeated K\sphinxhyphen{}Fold cross validation

\item {} 
\sphinxAtStartPar
Train/Test split

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Variable selection:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Genetic agorithm variable selection for PLS only

\item {} 
\sphinxAtStartPar
Particle Swarm Optimization variable selection for PLS only

\item {} 
\sphinxAtStartPar
Spearman Ranking variable selection for PLS only

\end{itemize}

\end{description}

\end{itemize}


\section{History}
\label{\detokenize{Overview:history}}\begin{itemize}
\item {} 
\sphinxAtStartPar
2009: Developed and used during my PhD thesis at the Laboratory of chemometrics and cheminformatics at the University of Perugia

\item {} 
\sphinxAtStartPar
2016: Open\sphinxhyphen{}source the code release under GPLv3. The development still continue under open\sphinxhyphen{}source licence

\end{itemize}


\section{Integration with other open\sphinxhyphen{}source projects}
\label{\detokenize{Overview:integration-with-other-open-source-projects}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Libscientific is the engine of \sphinxhref{https://github.com/gmrandazzo/QStudioMetrics}{QStudioMetrics}, a software to develop easy multivariate analysis

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/gmrandazzo/MolecularFramework}{MolecularFramework} a c/c++ cheminformatic library to analyze 3D molecules and develop process 3D information for model development

\end{itemize}


\section{Licensing}
\label{\detokenize{Overview:licensing}}
\sphinxAtStartPar
This documentation is copiright (C) 2011\sphinxhyphen{}2020 by Giuseppe Marco Randazzo

\sphinxAtStartPar
This work is licensed under the Creative Commons Attribution\sphinxhyphen{}ShareAlike 4.0 License. To view a copy of this license, visit \sphinxurl{http://creativecommons.org/licenses/by-sa/4.0/} or send a letter to Creative Commons, 543 Howard Street, 5th Floor, San Francisco, California, 94105, USA.

\sphinxstepscope


\chapter{Install}
\label{\detokenize{Install:install}}\label{\detokenize{Install::doc}}
\sphinxAtStartPar
The installation works for Linux/macOS and Windows.


\section{Requirements}
\label{\detokenize{Install:requirements}}\begin{itemize}
\item {} 
\sphinxAtStartPar
A development environment (On windows msys/msys2 or visual studio)

\item {} 
\sphinxAtStartPar
A c/fortran compiler

\item {} 
\sphinxAtStartPar
Cmake

\item {} 
\sphinxAtStartPar
python3 (if you whant to use the library in python)

\end{itemize}


\section{Installation process}
\label{\detokenize{Install:installation-process}}
\sphinxAtStartPar
First you need to install the C library following these instructions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{gmrandazzo}\PYG{o}{/}\PYG{n}{libscientific}\PYG{o}{.}\PYG{n}{git}
\PYG{n}{cd} \PYG{n}{libscientific}
\PYG{n}{mkdir} \PYG{n}{build}
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{j5}
\PYG{n}{sudo} \PYG{n}{make} \PYG{n}{install}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then, if you want to use the library in python, you have also to install the python package.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{n}{src}\PYG{o}{/}\PYG{n}{python\PYGZus{}bindings}
\PYG{n}{python3} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{install}

\PYG{o+ow}{or}

\PYG{n}{pip3} \PYG{n}{install} \PYG{n}{libscientific}
\end{sphinxVerbatim}


\section{Packages}
\label{\detokenize{Install:packages}}
\sphinxAtStartPar
On macOS you can install libscientific via homebrew

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{brew} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{HEAD} \PYG{n}{libscientific}
\PYG{n}{brew} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{HEAD} \PYG{n}{libscientific}\PYG{o}{\PYGZhy{}}\PYG{n}{python3}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Getting started in C}
\label{\detokenize{GettingStartedInC:getting-started-in-c}}\label{\detokenize{GettingStartedInC::doc}}
\sphinxAtStartPar
Every data type object in libscientific is stored in the HEAP and then supports
dynamic memory allocation.

\sphinxAtStartPar
Hence, every data object such as matrix, vectors, tensors, models, in general,
need to be manually allocated/deallocated by the programmer using the library predefined
constructs “NewSOMETHING(\&…);” and “DelSOMETHING(\&…);”.

\sphinxAtStartPar
Hence, every data object is a pointer and needs to pass by reference “\&”.
To avoid memory fragmentation problems, please, consider deallocating every allocated variable at the end of your program :\sphinxhyphen{})


\section{Compile a program that use libscientific}
\label{\detokenize{GettingStartedInC:compile-a-program-that-use-libscientific}}
\sphinxAtStartPar
A program that use libscientific requires only one directive as follow:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}scientific.h\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
and to compile the code with a C or C++ compiler linking with \sphinxtitleref{\sphinxhyphen{}lscientific}
and specify the right paths using the \sphinxtitleref{\sphinxhyphen{}L\textless{}library path/of/libscientific} and \sphinxtitleref{\sphinxhyphen{}I\textless{}include path/of libscientific\textgreater{}}
options.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gcc}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{o}\PYG{+w}{ }\PYG{n}{example1}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{L}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{I}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{include}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{lscientific}\PYG{+w}{ }\PYG{n}{example1}\PYG{p}{.}\PYG{n}{c}
\end{sphinxVerbatim}


\chapter{Vector operations}
\label{\detokenize{GettingStartedInC:vector-operations}}

\section{Create/Allocate a vector}
\label{\detokenize{GettingStartedInC:create-allocate-a-vector}}
\sphinxAtStartPar
There are four different types of vectors
\begin{itemize}
\item {} 
\sphinxAtStartPar
Double vector: dvector

\item {} 
\sphinxAtStartPar
Integer vector: ivector

\item {} 
\sphinxAtStartPar
Unsigned integer vector: uivector

\item {} 
\sphinxAtStartPar
String vector: strvector

\end{itemize}

\sphinxAtStartPar
Here we show an example on how to allocate/deallocate these four vector types.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}scientific.h\PYGZgt{}}


\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{  }\PYG{c+cm}{/* Define the variable vector, which in this case is a double vector.}
\PYG{c+cm}{   * If we would like to use an integer or an unsigned integer or a }
\PYG{c+cm}{   * string vector instead this construct became}
\PYG{c+cm}{   * ivector *v; or uivector *v; or strvector *v;}
\PYG{c+cm}{   */}

\PYG{+w}{  }\PYG{n}{dvector}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{v}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{NewDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{v}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Allocate the memory space.}

\PYG{+w}{  }\PYG{c+c1}{// Fill the value inside the vector}
\PYG{+w}{  }\PYG{k}{for}\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{v}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}

\PYG{+w}{  }\PYG{c+c1}{// Show the vector values to video}
\PYG{+w}{  }\PYG{n}{PrintDVector}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// Free the memory space}
\PYG{+w}{  }\PYG{n}{DelDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\end{sphinxVerbatim}


\section{Append a value to a given vector}
\label{\detokenize{GettingStartedInC:append-a-value-to-a-given-vector}}
\sphinxAtStartPar
Here we show an example on how to append a value to a vector.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}scientific.h\PYGZgt{}}


\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/*}
\PYG{c+cm}{   * We define here the double vector. }
\PYG{c+cm}{   * If we would like to utilize another vector}
\PYG{c+cm}{   * we can change dvector with the other three possibilities:}
\PYG{c+cm}{   * \PYGZhy{} uivector}
\PYG{c+cm}{   * \PYGZhy{} ivector}
\PYG{c+cm}{   * \PYGZhy{} strvector}
\PYG{c+cm}{   *}
\PYG{c+cm}{   */}
\PYG{+w}{  }\PYG{n}{dvector}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{v}\PYG{p}{;}

\PYG{+w}{  }\PYG{n}{NewDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{v}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// We intialize the vector }

\PYG{+w}{  }\PYG{c+c1}{// We add 5 numbers}
\PYG{+w}{  }\PYG{k}{for}\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{v}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}
\PYG{+w}{ }
\PYG{+w}{  }\PYG{c+c1}{// We append a new number}
\PYG{+w}{  }\PYG{n}{DVectorAppend}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{v}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{123.4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }
\PYG{+w}{  }\PYG{c+c1}{// Print to video the result}
\PYG{+w}{  }\PYG{n}{PrintDvector}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// Free up the memory}
\PYG{+w}{  }\PYG{n}{DelDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\end{sphinxVerbatim}


\section{Work with string vectors}
\label{\detokenize{GettingStartedInC:work-with-string-vectors}}

\chapter{Matrix operations}
\label{\detokenize{GettingStartedInC:matrix-operations}}
\sphinxAtStartPar
Matrix is a user\sphinxhyphen{}defined data type that contains:
\sphinxhyphen{} the number of rows
\sphinxhyphen{} the number of columns
\sphinxhyphen{} the 2D data array, which defines the matrix.

\sphinxAtStartPar
The data array is selected explicitly as a double type to work with an extensive range of numbers.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef}\PYG{+w}{ }\PYG{k}{struct}\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{o}{*}\PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{row}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{col}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{n}{matrix}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Create/Allocate a matrix with a specific size}
\label{\detokenize{GettingStartedInC:create-allocate-a-matrix-with-a-specific-size}}
\sphinxAtStartPar
Create a simple matrix of 10 rows and 15 columns and fill it with numbers.

\sphinxAtStartPar
Then print it to the terminal using “PrintMatrix();”

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}scientific.h\PYGZgt{}}


\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{m}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition of the pointer matrix variable}
\PYG{+w}{    }\PYG{n}{NewMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Create the matrix with 10 rows and 15 columns. Each value in the matrix is 0.}
\PYG{+w}{    }\PYG{k}{for}\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{15}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Fill the matrix values with these numbers}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Print to video the matrix content}
\PYG{+w}{    }\PYG{n}{DelMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Free the memory space}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Initialize an empty matrix and append a row/column to it}
\label{\detokenize{GettingStartedInC:initialize-an-empty-matrix-and-append-a-row-column-to-it}}
\sphinxAtStartPar
An empty matrix is an object with rows and cols equal to 0. However in that
matrix object we can add dynamically rows and columns and or resize it later on.

\sphinxAtStartPar
In this example we will initialize an empty matrix and we will add to it several rows.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}scientific.h\PYGZgt{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{mx}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition of the matrix variable as a pointer}
\PYG{+w}{    }\PYG{n}{dvector}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{row}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition of the row variable as a pointer }

\PYG{+w}{    }\PYG{n}{NewDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{row}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{row}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{row}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{i}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Fill one time the row vector }
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{n}{initMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{mx}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Initialize the empty matrix with rows and columns equal to 0}

\PYG{+w}{    }\PYG{k}{for}\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{MatrixAppendRow}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{mx}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{row}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Append 5 times the row to the matrix mx}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{mx}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Print to video the matrix }

\PYG{+w}{    }\PYG{n}{DelDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{row}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Free the memory space for the row vector}
\PYG{+w}{    }\PYG{n}{DelMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{mx}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Free the memory space for the matrix}
\PYG{p}{\PYGZcb{}}


\end{sphinxVerbatim}

\sphinxAtStartPar
Of course the same code can be reused to add a columns using the construct “MatrixAppendCol” instead of “MatrixAppendRow”.


\section{Matrix x Column vector dot product}
\label{\detokenize{GettingStartedInC:matrix-x-column-vector-dot-product}}
\sphinxAtStartPar
In this example we illustrate the product between a matrix of sizes M x N and a column double vector of size N.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}scientific.h\PYGZgt{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{mx}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition of the matrix variable as a pointer}
\PYG{+w}{    }\PYG{n}{dvector}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{cvect}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition of the column vector as a pointer }
\PYG{+w}{    }\PYG{n}{dvector}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{result}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition of the result vector between the matrix and the column vector}

\PYG{+w}{    }\PYG{n}{NewDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{cvect}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{cvect}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cvect}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{i}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Fill one time the row vector }
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{n}{NewMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{mx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{23}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Initialize a matrix with 23 rows and 15 columns}

\PYG{+w}{    }\PYG{k}{for}\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{mx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{row}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{mx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{col}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{mx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{NewDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{result}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{23}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{MatrixDVectorDotProduct}\PYG{p}{(}\PYG{n}{mx}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{cvect}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+cm}{/*}
\PYG{c+cm}{     * or MT\PYGZus{}MatrixDVectorDotProduct if you want to run the multitask operation.}
\PYG{c+cm}{     * This function is usefull for large matrix.}
\PYG{c+cm}{     */}


\PYG{+w}{    }\PYG{n}{PrintDVector}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Print to video the result}
\PYG{+w}{    }\PYG{c+c1}{// Free the memory spaces}
\PYG{+w}{    }\PYG{n}{DelDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{n}{DelDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{cvect}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{DelMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{mx}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\end{sphinxVerbatim}


\section{Transpose a matrix}
\label{\detokenize{GettingStartedInC:transpose-a-matrix}}
\sphinxAtStartPar
A matrix transpose is an operation that flips a matrix over its diagonal.
Here is an example that shows how to produce a transpose of a given matrix.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}scientific.h\PYGZgt{}}


\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{m\PYGZus{}T}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition of the pointer matrix variable}
\PYG{+w}{    }\PYG{n}{NewMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Create the matrix with 10 rows and 15 columns. Each value in the matrix is 0.}
\PYG{+w}{    }\PYG{n}{NewMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m\PYGZus{}T}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{col}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{row}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Create the transposed matrix with the flip of the columns and rows size}

\PYG{+w}{    }\PYG{k}{for}\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{15}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Fill the matrix values with these numbers}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{MatrixTranspose}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{m\PYGZus{}T}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Print to video the original matrix content}
\PYG{+w}{    }\PYG{n}{puts}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Transposed matrix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{m\PYGZus{}T}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Print to video the transposed matrix }
\PYG{+w}{    }\PYG{c+c1}{// Free the memory spaces}
\PYG{+w}{    }\PYG{n}{DelMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{DelMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m\PYGZus{}T}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Invert a matrix}
\label{\detokenize{GettingStartedInC:invert-a-matrix}}
\sphinxAtStartPar
In this example we show how to invert a matrix with libscientific

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}scientific.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}math.h\PYGZgt{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{m}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition of the matrix variable as a pointer}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{m\PYGZus{}inv}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition of the inverted matrix variable as a pointer }

\PYG{+w}{    }\PYG{n}{NewMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Allocate the matrix to invert }
\PYG{+w}{    }\PYG{n}{MatrixInitRandomFloat}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}3.}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Random fill the matrix with values within a range \PYGZhy{}3 \PYGZlt{} x \PYGZlt{} 3}
\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Print to video the matrix }

\PYG{+w}{    }\PYG{n}{initMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m\PYGZus{}inv}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Initialize the matrix to invert}
\PYG{+w}{    }\PYG{n}{MatrixInversion}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{m\PYGZus{}inv}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Invert the matrix}

\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{det}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fabs}\PYG{p}{(}\PYG{n}{MatrixDeterminant}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Calculate the determinant}

\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Determinant \PYGZpc{}.4f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{det}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Print to video the matrix determinant}
\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{m\PYGZus{}inv}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Print to video the inverted matrix}

\PYG{+w}{    }\PYG{c+c1}{// Free the memory spaces}
\PYG{+w}{    }\PYG{n}{DelMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m\PYGZus{}inv}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{DelMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\end{sphinxVerbatim}


\section{Calculate eigenvectors and eigenvalues of a matrix}
\label{\detokenize{GettingStartedInC:calculate-eigenvectors-and-eigenvalues-of-a-matrix}}
\sphinxAtStartPar
This example shows how to calculate eigenvectors and eigenvalues of an N x N real nonsymmetric matrix.
The eigenvector/eigenvalue is computed thanks to the dgeev.f code extracted from the Lapack library.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}scientific.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}math.h\PYGZgt{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{m}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition of the matrix variable as a pointer}
\PYG{+w}{    }\PYG{n}{dvector}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{eval}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition the variable to store the eigenvalues}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{evect}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition of the variable were to store the eigenvectors}

\PYG{+w}{    }\PYG{n}{NewMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Allocate the matrix to invert }
\PYG{+w}{    }\PYG{n}{MatrixInitRandomFloat}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}3.}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Random fill the matrix with values within a range \PYGZhy{}3 \PYGZlt{} x \PYGZlt{} 3}
\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Print to video the matrix }

\PYG{+w}{    }\PYG{c+c1}{// Initialize the variables}
\PYG{+w}{    }\PYG{n}{initDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{eval}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{initMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{evect}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{EVectEval}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{eval}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{evect}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Calculate the eigenvectors and associated eigenvalues}

\PYG{+w}{    }\PYG{n}{PrintDVector}\PYG{p}{(}\PYG{n}{eval}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Print to video the eigenvalues}
\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{evect}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Print to video the eigenvectors. Each column correspond to an eingenvalue}

\PYG{+w}{    }\PYG{c+c1}{// Free the memory spaces}
\PYG{+w}{    }\PYG{n}{DelDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{eval}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{DelMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{evect}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{DelMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\end{sphinxVerbatim}


\chapter{Tensor operations}
\label{\detokenize{GettingStartedInC:tensor-operations}}
\sphinxAtStartPar
TO BE COMPLETED


\chapter{Multivariate analysis algorithms}
\label{\detokenize{GettingStartedInC:multivariate-analysis-algorithms}}
\sphinxAtStartPar
In this section, you will find examples of running multivariate analysis algorithms.
In particular, the algorithm described here is extracted from official scientific publications
and is adapted to run in multithreading to speed up the calculation.
\begin{itemize}
\item {} 
\sphinxAtStartPar
PCA and PLS implements the NIPALS algorithm described in the following publication:

\end{itemize}

\begin{DUlineblock}{0em}
\item[] P. Geladi, B.R. Kowalski
\item[] Partial least\sphinxhyphen{}squares regression: a tutorial
\item[] Analytica Chimica Acta Volume 185, 1986, Pages 1\sphinxhyphen{}17
\item[] DOI:10.1016/0003\sphinxhyphen{}2670(86)80028\sphinxhyphen{}9
\end{DUlineblock}


\section{Principal Component Analysis (PCA)}
\label{\detokenize{GettingStartedInC:principal-component-analysis-pca}}
\sphinxAtStartPar
Here is an example that shows how to compute a principal component analysis on a matrix.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}scientific.h\PYGZgt{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{m}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition of the input matrix }
\PYG{+w}{    }\PYG{n}{PCAMODEL}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{model}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Definition of the PCA model}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{nobj}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{nvars}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{8}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{NewMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nobj}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nvars}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// Fill with random values the matrix m}
\PYG{+w}{    }\PYG{n}{srand}\PYG{p}{(}\PYG{n}{nobj}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nobj}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nvars}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{randDouble}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}


\PYG{+w}{    }\PYG{n}{NewPCAModel}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{model}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Allocation of the PCA model}
\PYG{+w}{    }\PYG{n}{PCA}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{model}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Calculation of the PCA on matrix m using unit variance scaling (1) and the extraction of 5 principal components }

\PYG{+w}{    }\PYG{n}{PrintPCA}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Print to video the PCA results}

\PYG{+w}{    }\PYG{c+cm}{/* Of course you can print in a separate way the different results contained in the model variable}
\PYG{c+cm}{     * model\PYGZhy{}\PYGZgt{}scores is the matrix of scores}
\PYG{c+cm}{     * model\PYGZhy{}\PYGZgt{}loadings is the matrix of loadings}
\PYG{c+cm}{     * model\PYGZhy{}\PYGZgt{}colavg is the column average obtained from the input matrix}
\PYG{c+cm}{     * model\PYGZhy{}\PYGZgt{}scaling is the scaling factor obtained from the input matrix}
\PYG{c+cm}{     */}

\PYG{+w}{    }\PYG{c+c1}{// Free the memory spaces}
\PYG{+w}{    }\PYG{n}{DelPCAModel}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{model}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{DelMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\end{sphinxVerbatim}


\section{Partial Least Squares (PLS)}
\label{\detokenize{GettingStartedInC:partial-least-squares-pls}}
\sphinxAtStartPar
A matrix of features or independent vIariables and a matrix of targets or dependent variables is requested to calculate a PLS model.
Here is a simple example that shows how to calculate a PLS model.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}scientific.h\PYGZgt{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{y}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Define the feature matrix x and the target to predict y}
\PYG{+w}{    }\PYG{n}{dvector}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{betas}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Define the beta coefficients}
\PYG{+w}{    }\PYG{n}{PLSMODEL}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{m}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// Allocate the matrix}
\PYG{+w}{    }\PYG{n}{NewMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{14}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{NewMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{14}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// Fill the matrix with values}
\PYG{+w}{    }\PYG{c+c1}{// This is a manual filling.}
\PYG{+w}{    }\PYG{c+c1}{// Of course we can read a csv file and fill it automatically}

\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{4.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{4.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{84.1400}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0500}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{235.1500}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{5.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{5.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{79.1000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.9780}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{231}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{4.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{5.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{67.0900}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.9700}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{249.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{4.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{4.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{68.0700}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.9360}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{187.3500}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{3.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{4.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{2.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{68.0800}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0300}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{363.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{9.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{7.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{129.1600}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0900}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{258.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{10.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{8.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{128.1600}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.1500}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{352.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{6.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{6.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{78.1118}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.8765}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{278.6400}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{16.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{10.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{202.2550}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.2710}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{429.1500}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{6.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{12.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{84.1600}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.7800}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{279.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{4.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{8.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{72.1100}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.8900}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{164.5000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{4.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{9.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{71.1100}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.8660}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{210.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{5.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{11.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{85.1500}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.8620}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{266.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{5.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{10.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0000}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{86.1300}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.8800}\PYG{p}{;}\PYG{+w}{  }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{228.0000}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{357.1500}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{388.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{403.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{304.5500}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{529.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{510.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{491.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{353.3000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{666.6500}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{354.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{339.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{360.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{379.0000}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{361.0000}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// Allocate the PLS model}
\PYG{+w}{    }\PYG{n}{NewPLSModel}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+cm}{/* Calculate the partial least squares algorithm taking as input:}
\PYG{c+cm}{     * x: the feature matrix x}
\PYG{c+cm}{     * y: the target matrix y}
\PYG{c+cm}{     * nlv: the number of latent variable nlv}
\PYG{c+cm}{     * xautoscaling: the autoscaling type for the x matrix}
\PYG{c+cm}{     * yautoscaling: the autoscaling type for the y Matrix}
\PYG{c+cm}{     * model: the PLSMODEL previously allocated}
\PYG{c+cm}{     * ssignal: a scientific signal to stop the calculation if requested by the user}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * more information in the pls.h header file}
\PYG{c+cm}{     * void PLS(matrix *mx, matrix *my, size\PYGZus{}t nlv, size\PYGZus{}t xautoscaling, size\PYGZus{}t yautoscaling, PLSMODEL *model, ssignal *s);}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{n}{PLS}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{PrintPLSModel}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Print to video the PLS model}

\PYG{+w}{    }\PYG{c+cm}{/*Validate the model using the internal validation method*/}
\PYG{+w}{    }\PYG{n}{MODELINPUT}\PYG{+w}{ }\PYG{n}{minpt}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Define the model input for the validation method}
\PYG{+w}{    }\PYG{n}{minpt}\PYG{p}{.}\PYG{n}{mx}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{minpt}\PYG{p}{.}\PYG{n}{my}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{minpt}\PYG{p}{.}\PYG{n}{nlv}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{minpt}\PYG{p}{.}\PYG{n}{xautoscaling}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{minpt}\PYG{p}{.}\PYG{n}{yautoscaling}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// Use the boot strap random group cross validation.}
\PYG{+w}{    }\PYG{n}{BootstrapRandomGroupsCV}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{minpt}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{\PYGZus{}PLS\PYGZus{}}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{predicted\PYGZus{}y}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pred\PYGZus{}residuals}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// We can also compute leave one out in case...}
\PYG{+w}{    }\PYG{c+c1}{// LeaveOneOut(\PYGZam{}minpt, \PYGZus{}PLS\PYGZus{}, \PYGZam{}m\PYGZhy{}\PYGZgt{}predicted\PYGZus{}y, \PYGZam{}m\PYGZhy{}\PYGZgt{}pred\PYGZus{}residuals, 4, NULL, 0);}

\PYG{+w}{    }\PYG{c+c1}{// Calculate the model validation statistics}
\PYG{+w}{    }\PYG{n}{PLSRegressionStatistics}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{predicted\PYGZus{}y}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{q2y}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sdep}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{bias}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{//Print to video the results of the validation and the predicted values}

\PYG{+w}{    }\PYG{n}{puts}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Q2 Cross Validation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{q2y}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{puts}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SDEP Cross Validation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sdep}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{puts}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BIAS Cross Validation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{bias}\PYG{p}{)}\PYG{p}{;}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// Calculate the beta coefficients to see the importance of each feature}
\PYG{+w}{    }\PYG{n}{puts}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Beta coefficients}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{initDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{betas}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{PLSBetasCoeff}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{GetLVCCutoff}\PYG{p}{(}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{q2y}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{betas}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// GetLVCCutoff select the best Q2 value from all the possibilities}
\PYG{+w}{    }\PYG{n}{PrintDVector}\PYG{p}{(}\PYG{n}{betas}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{puts}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{PREDICTED VALUES}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{predicted\PYGZus{}y}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{puts}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{PREDICTED RESIDUALS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pred\PYGZus{}residuals}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{puts}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{REAL Y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{PrintMatrix}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// Free the memory spaces}
\PYG{+w}{    }\PYG{n}{DelDVector}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{betas}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{DelPLSModel}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{DelMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{DelMatrix}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Getting started in Python}
\label{\detokenize{GettingStartedInPython:getting-started-in-python}}\label{\detokenize{GettingStartedInPython::doc}}
\sphinxAtStartPar
Every data type object in libscientific is stored in the HEAP and then supports dynamic memory allocation.

\sphinxAtStartPar
In python, there is no need to allocate/deallocate matrix/vectors/tensors and models in general
because the python binding itself automatically handles them.


\section{Use libscientific in python}
\label{\detokenize{GettingStartedInPython:use-libscientific-in-python}}
\sphinxAtStartPar
First, you need to install the c library and the python package.
Please follow the process described \sphinxhref{http://gmrandazzo.github.io/libscientific/Source/\_build/html/Install.html}{here}.

\sphinxAtStartPar
A program that use libscientific requires to import the python binding as follows

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{libscientific}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}


\chapter{Vector operations}
\label{\detokenize{GettingStartedInPython:vector-operations}}

\section{Create a vector in python}
\label{\detokenize{GettingStartedInPython:create-a-vector-in-python}}
\sphinxAtStartPar
There are four different types of vectors
\begin{itemize}
\item {} 
\sphinxAtStartPar
Double vector: dvector

\item {} 
\sphinxAtStartPar
Integer vector: ivector

\item {} 
\sphinxAtStartPar
Unsigned integer vector: uivector

\item {} 
\sphinxAtStartPar
String vector: strvector

\end{itemize}

\sphinxAtStartPar
Here we show an example on how create these four vector types.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/env python3}
\PYG{k+kn}{import} \PYG{n+nn}{libscientific}
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{random}

\PYG{c+c1}{\PYGZsh{} Create a list of values that you whant to convert to a double vector}
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Transform the list a into a double vector d}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{libscientific}\PYG{o}{.}\PYG{n}{vector}\PYG{o}{.}\PYG{n}{DVector}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Just print to video the content of vector d}
\PYG{n}{d}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} If you want to catch the value in position 1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{d}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} If you want to modify the value in position 1}
\PYG{n}{d}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZsh{}If you want to get back the result as a \PYGZdq{}list\PYGZdq{} }
\PYG{n}{dlst} \PYG{o}{=} \PYG{n}{d}\PYG{o}{.}\PYG{n}{tolist}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{dlst}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Append a value to a given vector}
\label{\detokenize{GettingStartedInPython:append-a-value-to-a-given-vector}}
\sphinxAtStartPar
Here we show an example on how to append a value to a vector.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/env python3}
\PYG{k+kn}{import} \PYG{n+nn}{libscientific}
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{random}

\PYG{c+c1}{\PYGZsh{} Create a list of values that you whant to convert to a double vector}
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{libscientific}\PYG{o}{.}\PYG{n}{vector}\PYG{o}{.}\PYG{n}{DVector}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} print the output of the double vector d}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{orig vector}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{d}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} append the value 0.98765 at the end of d}
\PYG{n}{d}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mf}{0.98765}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{append 0.98765 at the end}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{d}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} extend the vector d with more other values from a list}
\PYG{n}{d}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.4362}\PYG{p}{,} \PYG{l+m+mf}{0.34529}\PYG{p}{,} \PYG{l+m+mf}{0.99862}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{extent the vector with 3 more values}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{d}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Matrix operations}
\label{\detokenize{GettingStartedInPython:matrix-operations}}
\sphinxAtStartPar
Matrix is a user\sphinxhyphen{}defined data type that contains information in regards to
\sphinxhyphen{} the number of rows
\sphinxhyphen{} the number of columns
\sphinxhyphen{} the 2D data array which defines the matrix

\sphinxAtStartPar
The data array in python uses the c language implementation.
However, memory allocation/destruction is carried out directly from the python class.
Hence there is no need to free up the memory manually.


\section{Create a matrix in python}
\label{\detokenize{GettingStartedInPython:create-a-matrix-in-python}}
\sphinxAtStartPar
In this example, we show how to create a matrix from a list of lists (or numpy array),
modify its content and convert it again to a list of lists.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/env python3}
\PYG{k+kn}{import} \PYG{n+nn}{libscientific}
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{random}

\PYG{c+c1}{\PYGZsh{} Create a random list of list }
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Convert the list of list matrix into a libscientific matrix}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{libscientific}\PYG{o}{.}\PYG{n}{matrix}\PYG{o}{.}\PYG{n}{Matrix}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Get the value at row 1, column 1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Get value example}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{m}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Modify the value at row 1, column 1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Set value example}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{m}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}
\PYG{n}{m}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Convert the matrix again to a list of list}
\PYG{n}{mlst} \PYG{o}{=} \PYG{n}{m}\PYG{o}{.}\PYG{n}{tolist}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{mlst}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Tensor operations}
\label{\detokenize{GettingStartedInPython:tensor-operations}}
\sphinxAtStartPar
TO BE COMPLETED


\chapter{Multivariate analysis algorithms}
\label{\detokenize{GettingStartedInPython:multivariate-analysis-algorithms}}
\sphinxAtStartPar
In this section, you will find examples of running multivariate analysis algorithms.
In particular, the algorithm described here is extracted from official libscientific publications and is adapted to run in multithreading to speed up the calculation.
\begin{itemize}
\item {} 
\sphinxAtStartPar
PCA and PLS implements the NIPALS algorithm described in the following publication:

\end{itemize}

\begin{DUlineblock}{0em}
\item[] P. Geladi, B.R. Kowalski
\item[] Partial least\sphinxhyphen{}squares regression: a tutorial
\item[] Analytica Chimica Acta Volume 185, 1986, Pages 1\textendash{}17
\item[] DOI:10.1016/0003\sphinxhyphen{}2670(86)80028\sphinxhyphen{}9
\end{DUlineblock}


\section{Principal Component Analysis (PCA)}
\label{\detokenize{GettingStartedInPython:principal-component-analysis-pca}}
\sphinxAtStartPar
Here is an example that shows to compute a principal component analysis on a matrix.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/env python3}

\PYG{k+kn}{import} \PYG{n+nn}{libscientific}
\PYG{k+kn}{import} \PYG{n+nn}{random}

\PYG{k}{def} \PYG{n+nf}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{n}{decimals}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{m}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{decimals}\PYG{p}{)}\PYG{p}{)} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{123456}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create a random matrix of 10 objects and 4 features}
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Original Matrix}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Compute 2 Principal components using the UV scaling (unit variance scaling)}
\PYG{n}{model} \PYG{o}{=} \PYG{n}{libscientific}\PYG{o}{.}\PYG{n}{pca}\PYG{o}{.}\PYG{n}{PCA}\PYG{p}{(}\PYG{n}{scaling}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{npc}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Fit the model}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Show the scores}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Showing the PCA scores}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{scores} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{get\PYGZus{}scores}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{scores}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Show the loadings}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Showing the PCA loadings}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{loadings} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{get\PYGZus{}loadings}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{loadings}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Show the explained variance}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{get\PYGZus{}exp\PYGZus{}variance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Reconstruct the original PCA matrix from the 2 principal components}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Reconstruct the original PCA matrix using the PCA Model}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ra} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{reconstruct\PYGZus{}original\PYGZus{}matrix}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{ra}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Partial Least Squares (PLS)}
\label{\detokenize{GettingStartedInPython:partial-least-squares-pls}}
\sphinxAtStartPar
A matrix of features or independent variables and a matrix of targets or dependent variables is requested to calculate a PLS model.

\sphinxAtStartPar
Here is a simple example that shows how to calculate a PLS model.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/env python3}

\PYG{k+kn}{import} \PYG{n+nn}{libscientific}
\PYG{k+kn}{import} \PYG{n+nn}{random}

\PYG{k}{def} \PYG{n+nf}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{n}{decimals}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{m}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{decimals}\PYG{p}{)}\PYG{p}{)} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{123456}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{xp} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Original Matrix}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{XP}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{xp}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Computing PLS ...}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{model} \PYG{o}{=} \PYG{n}{libscientific}\PYG{o}{.}\PYG{n}{pls}\PYG{o}{.}\PYG{n}{PLS}\PYG{p}{(}\PYG{n}{nlv}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{xscaling}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{yscaling}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Showing the PLS T scores}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{tscores} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{get\PYGZus{}tscores}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{tscores}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Showing the PLS U scores}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{uscores} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{get\PYGZus{}uscores}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{uscores}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Showing the PLS P loadings}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ploadings} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{get\PYGZus{}ploadings}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{ploadings}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Showing the X Variance}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{get\PYGZus{}exp\PYGZus{}variance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Predict XP}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{py}\PYG{p}{,} \PYG{n}{pscores} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{xp}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Predicted Y for all LVs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{py}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Predicted Scores}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{mx\PYGZus{}to\PYGZus{}video}\PYG{p}{(}\PYG{n}{pscores}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Licensing}
\label{\detokenize{Licensing:licensing}}\label{\detokenize{Licensing::doc}}
\sphinxAtStartPar
Libscientific is distributed under GPLv3 license.
To know more in details how the licens work please read the file “LICENSE” or go to “\sphinxurl{http://www.gnu.org/licenses/gpl-3.0.en.html}”


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}